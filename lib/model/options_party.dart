import 'package:flutter/foundation.dart';
import 'package:quiver/core.dart';


import 'board/board.dart';
import 'index.dart';

// THIS FILE IS AUTO GENERATED.
// Generated by `flutter pub run json_to_model`
// See https://pub.dev/packages/json_to_model
// Input json file: jsons/options_party.json

@immutable
/// Options of the party parsed from a json file

class OptionsParty {

  const OptionsParty({
    required this.optionsGlobalParty,
    required this.optionsRounds,
  });

  final OptionsGlobalParty optionsGlobalParty;
  final List<OptionsRound> optionsRounds;

  factory OptionsParty.fromJson(Map<String,dynamic> json) => OptionsParty(
      optionsGlobalParty: OptionsGlobalParty.fromJson(json['options_global_party'] as Map<String, dynamic>),
      optionsRounds: (json['options_rounds'] as List? ?? []).map((e) => OptionsRound.fromJson(e as Map<String, dynamic>)).toList()
  );

  Map<String, dynamic> toJson() => {
    'options_global_party': optionsGlobalParty.toJson(),
    'options_rounds': optionsRounds.map((e) => e.toJson()).toList()
  };

  OptionsParty clone() => OptionsParty(
      optionsGlobalParty: optionsGlobalParty.clone(),
      optionsRounds: optionsRounds.map((e) => e.clone()).toList()
  );


  OptionsParty copyWith({
    OptionsGlobalParty? optionsGlobalParty,
    List<OptionsRound>? optionsRounds
  }) => OptionsParty(
    optionsGlobalParty: optionsGlobalParty ?? this.optionsGlobalParty,
    optionsRounds: optionsRounds ?? this.optionsRounds,
  );

  @override
  bool operator ==(Object other) => identical(this, other)
      || other is OptionsParty && optionsGlobalParty == other.optionsGlobalParty && optionsRounds == other.optionsRounds;

  @override
  int get hashCode => optionsGlobalParty.hashCode ^ optionsRounds.hashCode;
}

@immutable
class OptionsGlobalParty {

  const OptionsGlobalParty({
    required this.nbPlayerMin,
    required this.nbPlayerMax,
    required this.boardImageAssetsPath,
    required this.boardJsonAssetsPath,
  });

  final int nbPlayerMin;
  final int nbPlayerMax;
  final String boardImageAssetsPath;
  final String boardJsonAssetsPath;

  factory OptionsGlobalParty.fromJson(Map<String,dynamic> json) => OptionsGlobalParty(
      nbPlayerMin: json['nb_player_min'] as int,
      nbPlayerMax: json['nb_player_max'] as int,
      boardImageAssetsPath: json['board_image_assets_path'].toString(),
      boardJsonAssetsPath: json['board_json_assets_path'].toString()
  );

  Map<String, dynamic> toJson() => {
    'nb_player_min': nbPlayerMin,
    'nb_player_max': nbPlayerMax,
    'board_image_assets_path': boardImageAssetsPath,
    'board_json_assets_path': boardJsonAssetsPath
  };

  OptionsGlobalParty clone() => OptionsGlobalParty(
      nbPlayerMin: nbPlayerMin,
      nbPlayerMax: nbPlayerMax,
      boardImageAssetsPath: boardImageAssetsPath,
      boardJsonAssetsPath: boardJsonAssetsPath
  );


  OptionsGlobalParty copyWith({
    int? nbPlayerMin,
    int? nbPlayerMax,
    String? boardImageAssetsPath,
    String? boardJsonAssetsPath
  }) => OptionsGlobalParty(
    nbPlayerMin: nbPlayerMin ?? this.nbPlayerMin,
    nbPlayerMax: nbPlayerMax ?? this.nbPlayerMax,
    boardImageAssetsPath: boardImageAssetsPath ?? this.boardImageAssetsPath,
    boardJsonAssetsPath: boardJsonAssetsPath ?? this.boardJsonAssetsPath,
  );

  @override
  bool operator ==(Object other) => identical(this, other)
      || other is OptionsGlobalParty && nbPlayerMin == other.nbPlayerMin && nbPlayerMax == other.nbPlayerMax && boardImageAssetsPath == other.boardImageAssetsPath && boardJsonAssetsPath == other.boardJsonAssetsPath;

  @override
  int get hashCode => nbPlayerMin.hashCode ^ nbPlayerMax.hashCode ^ boardImageAssetsPath.hashCode ^ boardJsonAssetsPath.hashCode;
}

@immutable
class OptionsRound {

  const OptionsRound({
    required this.startPosition,
    required this.pointsSab,
    this.points,
    required this.vehicleSab,
    this.vehicle,
    required this.startShopAvailable,
    required this.aims,
  });

  final String startPosition;
  final bool pointsSab;
  final PointCard? points;
  final bool vehicleSab;
  final List<String>? vehicle;
  final bool startShopAvailable;
  final Aims aims;

  factory OptionsRound.fromJson(Map<String,dynamic> json) => OptionsRound(
      startPosition: json['start_position'].toString(),
      pointsSab: json['points_sab'] as bool,
      points: json['points'] != null ? PointCard.fromJson(json['points'] as Map<String, dynamic>) : null,
      vehicleSab: json['vehicle_sab'] as bool,
      vehicle: json['vehicle'] != null ? (json['vehicle'] as List? ?? []).map((e) => e as String).toList() : null,
      startShopAvailable: json['start_shop_available'] as bool,
      aims: Aims.fromJson(json['aims'] as Map<String, dynamic>)
  );

  Map<String, dynamic> toJson() => {
    'start_position': startPosition,
    'points_sab': pointsSab,
    'points': points?.toJson(),
    'vehicle_sab': vehicleSab,
    'vehicle': vehicle?.map((e) => e.toString()).toList(),
    'start_shop_available': startShopAvailable,
    'aims': aims.toJson()
  };

  OptionsRound clone() => OptionsRound(
      startPosition: startPosition,
      pointsSab: pointsSab,
      points: points?.clone(),
      vehicleSab: vehicleSab,
      vehicle: vehicle?.toList(),
      startShopAvailable: startShopAvailable,
      aims: aims.clone()
  );


  OptionsRound copyWith({
    String? startPosition,
    bool? pointsSab,
    Optional<PointCard?>? points,
    bool? vehicleSab,
    Optional<List<String>?>? vehicle,
    bool? startShopAvailable,
    Aims? aims
  }) => OptionsRound(
    startPosition: startPosition ?? this.startPosition,
    pointsSab: pointsSab ?? this.pointsSab,
    points: checkOptional(points, () => this.points),
    vehicleSab: vehicleSab ?? this.vehicleSab,
    vehicle: checkOptional(vehicle, () => this.vehicle),
    startShopAvailable: startShopAvailable ?? this.startShopAvailable,
    aims: aims ?? this.aims,
  );

  @override
  bool operator ==(Object other) => identical(this, other)
      || other is OptionsRound && startPosition == other.startPosition && pointsSab == other.pointsSab && points == other.points && vehicleSab == other.vehicleSab && vehicle == other.vehicle && startShopAvailable == other.startShopAvailable && aims == other.aims;

  @override
  int get hashCode => startPosition.hashCode ^ pointsSab.hashCode ^ points.hashCode ^ vehicleSab.hashCode ^ vehicle.hashCode ^ startShopAvailable.hashCode ^ aims.hashCode;
}

@immutable
class Aims {

  const Aims({
    required this.type,
    this.targets,
  });

  AimsTypeEnum get aimsTypeEnum => _aimsTypeEnumValues.map[type]!;
  final String type;
  final List<String>? targets;

  factory Aims.fromJson(Map<String,dynamic> json) => Aims(
      type: json['type'].toString(),
      targets: json['targets'] != null ? (json['targets'] as List? ?? []).map((e) => e as String).toList() : null
  );

  Map<String, dynamic> toJson() => {
    'type': type,
    'targets': targets?.map((e) => e.toString()).toList()
  };

  Aims clone() => Aims(
      type: type,
      targets: targets?.toList()
  );


  Aims copyWith({
    String? type,
    Optional<List<String>?>? targets
  }) => Aims(
    type: type ?? this.type,
    targets: checkOptional(targets, () => this.targets),
  );

  @override
  bool operator ==(Object other) => identical(this, other)
      || other is Aims && type == other.type && targets == other.targets;

  @override
  int get hashCode => type.hashCode ^ targets.hashCode;
}

enum AimsTypeEnum { Defined, Random }

extension AimsTypeEnumEx on AimsTypeEnum{
  String? get value => _aimsTypeEnumValues.reverse[this];
}

final _aimsTypeEnumValues = _AimsTypeEnumConverter({
  'defined': AimsTypeEnum.Defined,
  'random': AimsTypeEnum.Random,
});


class _AimsTypeEnumConverter<String, O> {
  final Map<String, O> map;
  Map<O, String>? reverseMap;

  _AimsTypeEnumConverter(this.map);

  Map<O, String> get reverse => reverseMap ??= map.map((k, v) => MapEntry(v, k));
}

